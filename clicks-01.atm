val SDL = require "SDL"
val TTF = require "SDL.ttf"
require "atmos"
set sdl = require "atmos.env.sdl"
val S = require "atmos.lang.streams"

SDL.init() --> assert
TTF.init() --> assert

defer {
    TTF.quit()
    SDL.quit()
}

set WIN = SDL.createWindow @{
	title  = "Atmos-SDL: Clicks",
	width  = 256,
	height = 256,
    flags  = @{ SDL.flags.OpenGL },
} --> assert

set REN = SDL.createRenderer(WIN,-1) --> assert
set sdl.ren = REN
set FNT = TTF.open("DejaVuSans.ttf", 10) --> assert

var txts = "-=- none -=-"

spawn {
    every :sdl.draw {
        REN::setDrawColor(0x000000)
        REN::clear()
        REN::setDrawColor(0xFFFFFF)
        REN::fillRect(rect)
        loop i,t in txts {
            sdl.write(FNT, t, @{x=256-70, y=20+(i*15)})
        }
        REN::present()
    }
}

func Buffer (src, ctl) {
    val ret = #{}
    val v = await(src)
    set ret[+] = v
    watching ctl {
        every v in src {
            set ret[+] = v
        }
    }
    ret
}

val clear =
    S.fr_spawns(Debounce, _or_(SDL.event.MouseButtonDown,SDL.event.MouseButtonUp), @1)
        ::tap \{ set txts = #{} }

val dn = 
    S.fr_awaits(:sdl.mouse.button.dn)
        ::tap \(_,pos,n) {
            set txts[+] = "dn (" ++ pos.x++','++pos.y ++"): " ++ n
        }

val up =
    S.fr_awaits(:sdl.mouse.button.up)
        ::tap \(_,pos,n) {
            set txts[+] = "up (" ++ pos.x++','++pos.y ++")"
        }

S.from@{clear,dn,up}::xpar()::to()
await(false)
